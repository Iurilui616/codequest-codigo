<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RUNE WEAVER - Shape Reality</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;font-family:'Rajdhani',sans-serif}
canvas{display:block;image-rendering:pixelated}
#gc{position:fixed;top:0;left:0;width:100vw;height:100vh;cursor:crosshair}

/* HUD */
#hud{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;user-select:none}
.stat-panel{position:absolute;top:16px;left:16px;display:flex;flex-direction:column;gap:6px}
.stat-row{display:flex;align-items:center;gap:8px}
.stat-icon{font-size:13px;width:20px;text-align:center}
.stat-bar{width:140px;height:10px;background:rgba(255,255,255,0.06);border-radius:5px;overflow:hidden;border:1px solid rgba(255,255,255,0.08)}
.stat-fill{height:100%;border-radius:5px;transition:width .2s}
.hp-fill{background:linear-gradient(90deg,#ff2244,#ff6688)}
.ink-fill{background:linear-gradient(90deg,#6633ff,#aa66ff)}
.xp-fill{background:linear-gradient(90deg,#00ccaa,#44ffcc)}
.stat-val{font-size:9px;color:rgba(255,255,255,.6);font-family:'Orbitron',monospace;min-width:44px;text-align:right}

.info-panel{position:absolute;top:16px;right:16px;display:flex;flex-direction:column;align-items:flex-end;gap:6px}
.info-pill{display:flex;align-items:center;gap:6px;background:rgba(8,12,24,0.85);padding:5px 12px;border-radius:16px;border:1px solid rgba(255,255,255,.06);font-family:'Orbitron',monospace;font-size:12px;font-weight:700;color:#ffd700}
.stage-badge{font-family:'Orbitron',monospace;font-size:9px;color:#00e5ff;letter-spacing:1px;background:rgba(8,12,24,0.85);padding:4px 10px;border-radius:10px;border:1px solid rgba(0,229,255,.15)}

/* Rune Drawing UI */
.rune-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.88);z-index:200;display:flex;align-items:center;justify-content:center;opacity:0;visibility:hidden;transition:all .4s;pointer-events:none}
.rune-overlay.active{opacity:1;visibility:visible;pointer-events:auto}
.rune-panel{width:min(600px,90vw);text-align:center}
.rune-title{font-family:'Orbitron',sans-serif;font-size:22px;color:#aa66ff;text-shadow:0 0 20px #aa66ff;margin-bottom:6px}
.rune-desc{font-size:13px;color:rgba(255,255,255,.5);margin-bottom:16px}
.rune-canvas-wrap{position:relative;width:360px;height:360px;margin:0 auto 16px;border:2px solid rgba(170,102,255,.3);border-radius:16px;overflow:hidden;background:rgba(10,5,20,0.9)}
#runeCanvas{width:100%;height:100%;cursor:crosshair}
.rune-hint{display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:16px}
.rune-target{width:80px;height:80px;border:2px solid rgba(170,102,255,.2);border-radius:12px;background:rgba(10,5,20,0.8);overflow:hidden}
.rune-target canvas{width:100%;height:100%}
.rune-match{font-family:'Orbitron',monospace;font-size:28px;font-weight:900;transition:color .2s}
.rune-btns{display:flex;gap:10px;justify-content:center}
.rune-btn{background:linear-gradient(145deg,rgba(170,102,255,.2),rgba(100,50,200,.15));border:1px solid rgba(170,102,255,.3);color:#fff;padding:10px 24px;border-radius:10px;font-family:'Orbitron',sans-serif;font-size:12px;cursor:pointer;transition:all .2s;pointer-events:auto}
.rune-btn:hover{background:rgba(170,102,255,.35);transform:translateY(-2px);box-shadow:0 6px 20px rgba(170,102,255,.3)}
.rune-btn.cast{background:linear-gradient(145deg,#6633ff,#4400cc);border-color:#aa66ff}

/* Menu Screen */
.screen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(ellipse at 50% 40%,#0a0515,#000);z-index:100;transition:opacity .5s,visibility .5s}
.screen.hidden{opacity:0;visibility:hidden;pointer-events:none}
.game-title{font-family:'Orbitron',sans-serif;font-size:clamp(28px,5.5vw,60px);font-weight:900;background:linear-gradient(180deg,#fff 0%,#aa66ff 50%,#ff2d78 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:tF 3s ease-in-out infinite}
@keyframes tF{0%,100%{transform:translateY(0)}50%{transform:translateY(-6px)}}
.game-sub{font-size:13px;color:rgba(255,255,255,.4);letter-spacing:8px;text-transform:uppercase;margin:6px 0 40px}
.menu-grid{display:grid;grid-template-columns:repeat(2,240px);gap:12px}
.menu-btn{background:linear-gradient(145deg,rgba(16,8,32,.9),rgba(6,3,16,.95));border:2px solid rgba(170,102,255,.12);border-radius:14px;padding:18px;cursor:pointer;transition:all .25s;text-align:left;overflow:hidden}
.menu-btn:hover{border-color:#aa66ff;transform:translateY(-3px);box-shadow:0 10px 30px rgba(170,102,255,.15)}
.menu-btn .bi{font-size:28px;margin-bottom:6px;display:block}
.menu-btn .bt{font-family:'Orbitron',sans-serif;font-size:13px;color:#fff;margin-bottom:3px}
.menu-btn .bd{font-size:11px;color:rgba(255,255,255,.35)}
.controls-hint{position:absolute;bottom:60px;display:flex;gap:16px;opacity:.3;font-size:9px;color:#fff;font-family:'Orbitron',monospace;letter-spacing:1px}
.controls-hint span{display:flex;align-items:center;gap:3px}
.key{background:rgba(255,255,255,.1);padding:2px 5px;border-radius:3px;border:1px solid rgba(255,255,255,.15);font-size:8px}

/* Toast */
.toast{position:fixed;top:80px;right:-360px;background:rgba(8,12,24,0.92);border:1px solid #aa66ff;border-radius:12px;padding:14px 18px;max-width:300px;transition:right .4s cubic-bezier(.4,0,.2,1);z-index:150}
.toast.show{right:16px}
.toast-title{color:#aa66ff;font-weight:700;font-size:11px;margin-bottom:4px}
.toast-text{color:rgba(255,255,255,.6);font-size:11px;line-height:1.4}

/* Level Up */
.lvlup{position:fixed;top:28%;left:50%;transform:translateX(-50%) scale(0);background:linear-gradient(145deg,rgba(170,102,255,.12),rgba(170,102,255,.03));border:2px solid #aa66ff;border-radius:16px;padding:24px 48px;text-align:center;z-index:110;transition:transform .45s cubic-bezier(.175,.885,.32,1.275)}
.lvlup.show{transform:translateX(-50%) scale(1)}
.lvlup-txt{font-family:'Orbitron',sans-serif;font-size:22px;color:#aa66ff;text-shadow:0 0 20px #aa66ff}
.lvlup-sub{color:rgba(255,255,255,.6);font-size:13px;margin-top:4px}

/* Death */
.death-screen{position:fixed;inset:0;background:rgba(0,0,0,.88);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:120;opacity:0;visibility:hidden;transition:all .4s}
.death-screen.show{opacity:1;visibility:visible}
.death-title{font-family:'Orbitron',sans-serif;font-size:36px;color:#ff2244;text-shadow:0 0 24px #ff2244;margin-bottom:10px}
.death-sub{color:rgba(255,255,255,.45);font-size:13px;margin-bottom:28px}
.retry-btn{background:#ff2244;border:none;color:#fff;padding:12px 36px;border-radius:10px;font-family:'Orbitron',sans-serif;font-size:13px;cursor:pointer;transition:all .2s;pointer-events:auto}
.retry-btn:hover{transform:scale(1.05);box-shadow:0 6px 20px rgba(255,34,68,.4)}

/* Spell Preview */
.spell-bar{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);display:flex;gap:8px}
.spell-slot{width:50px;height:50px;background:rgba(10,5,20,.9);border:2px solid rgba(170,102,255,.15);border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;pointer-events:auto;cursor:pointer;transition:all .15s}
.spell-slot:hover{transform:translateY(-3px);border-color:#aa66ff;box-shadow:0 6px 18px rgba(170,102,255,.25)}
.spell-slot.learned{border-color:#00ccaa}
.spell-slot .si{font-size:20px}
.spell-slot .sk{position:absolute;bottom:2px;font-size:7px;color:rgba(255,255,255,.4);font-family:'Orbitron',monospace}
</style>
</head>
<body>

<!-- HUD -->
<div id="hud" style="display:none">
  <div class="stat-panel">
    <div class="stat-row"><span class="stat-icon" style="color:#ff2244">&#9829;</span><div class="stat-bar"><div class="stat-fill hp-fill" id="hpBar" style="width:100%"></div></div><span class="stat-val" id="hpText">100/100</span></div>
    <div class="stat-row"><span class="stat-icon" style="color:#aa66ff">&#9670;</span><div class="stat-bar"><div class="stat-fill ink-fill" id="inkBar" style="width:100%"></div></div><span class="stat-val" id="inkText">100/100</span></div>
    <div class="stat-row"><span class="stat-icon" style="color:#00ccaa">&#9733;</span><div class="stat-bar"><div class="stat-fill xp-fill" id="xpBar" style="width:0%"></div></div><span class="stat-val" id="xpText">LVL 1</span></div>
  </div>
  <div class="info-panel">
    <div class="info-pill"><span>&#x2728;</span><span id="runesVal">0</span></div>
    <div class="stage-badge" id="stageBadge">REALM 1</div>
  </div>
  <div class="spell-bar" id="spellBar"></div>
</div>

<!-- Main Menu -->
<div class="screen" id="menuScreen">
  <h1 class="game-title">RUNE WEAVER</h1>
  <p class="game-sub">Draw Your Destiny</p>
  <div class="menu-grid">
    <div class="menu-btn" onclick="game.startGame()"><span class="bi">&#x1F3AE;</span><div class="bt">JORNADA</div><div class="bd">Desenhe runas para moldar a realidade</div></div>
    <div class="menu-btn" onclick="game.startGame()"><span class="bi">&#x270F;&#xFE0F;</span><div class="bt">PRATICA</div><div class="bd">Treine seus desenhos de runas</div></div>
    <div class="menu-btn" onclick="game.startGame()"><span class="bi">&#x2694;&#xFE0F;</span><div class="bt">ARENA</div><div class="bd">Desafios de combate infinitos</div></div>
    <div class="menu-btn" onclick="game.startGame()"><span class="bi">&#x2699;&#xFE0F;</span><div class="bt">OPCOES</div><div class="bd">Graficos e controles</div></div>
  </div>
  <div class="controls-hint">
    <span><span class="key">A</span><span class="key">D</span> mover</span>
    <span><span class="key">SPACE</span> pular</span>
    <span><span class="key">J</span> atacar</span>
    <span><span class="key">K</span> dash</span>
    <span><span class="key">MOUSE</span> desenhar runas no portal</span>
  </div>
</div>

<!-- Rune Drawing Overlay -->
<div class="rune-overlay" id="runeOverlay">
  <div class="rune-panel">
    <div class="rune-title" id="runeTitle">RUNA DO PORTAL</div>
    <div class="rune-desc" id="runeDesc">Desenhe o simbolo para abrir o portal para o proximo reino</div>
    <div class="rune-hint">
      <div class="rune-target"><canvas id="targetCanvas" width="160" height="160"></canvas></div>
      <div class="rune-match" id="matchPct" style="color:#ff4444">0%</div>
      <div style="font-size:11px;color:rgba(255,255,255,.35)">Precisao<br>minima: 60%</div>
    </div>
    <div class="rune-canvas-wrap">
      <canvas id="runeCanvas" width="360" height="360"></canvas>
    </div>
    <div class="rune-btns">
      <button class="rune-btn" onclick="game.clearRune()">LIMPAR</button>
      <button class="rune-btn cast" onclick="game.castRune()">CONJURAR RUNA</button>
      <button class="rune-btn" onclick="game.closeRune()">VOLTAR</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"><div class="toast-title" id="toastTitle">INFO</div><div class="toast-text" id="toastText"></div></div>

<!-- Level Up -->
<div class="lvlup" id="lvlBanner"><div class="lvlup-txt">LEVEL UP!</div><div class="lvlup-sub">Nivel <span id="newLvl">2</span></div></div>

<!-- Death Screen -->
<div class="death-screen" id="deathScreen"><div class="death-title">DISSIPADO</div><div class="death-sub" id="deathSub">Sua essencia se dispersou no reino 1</div><button class="retry-btn" onclick="game.retry()">RECRIAR ESSENCIA</button></div>

<!-- Game Canvas -->
<canvas id="gc"></canvas>

<script>
// ==================== AUDIO ====================
const SFX={ctx:null,m:null,
init(){this.ctx=new(window.AudioContext||window.webkitAudioContext)();this.m=this.ctx.createGain();this.m.gain.value=0.5;this.m.connect(this.ctx.destination)},
go(){if(!this.ctx)this.init();if(this.ctx.state==='suspended')this.ctx.resume()},
tone(f,d,t,sl,v){this.go();const o=this.ctx.createOscillator(),g=this.ctx.createGain();o.type=t||'square';o.frequency.setValueAtTime(f,this.ctx.currentTime);if(sl)sl.forEach((s,i)=>o.frequency.exponentialRampToValueAtTime(s,this.ctx.currentTime+d/sl.length*(i+1)));g.gain.setValueAtTime(v||0.08,this.ctx.currentTime);g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+d);o.connect(g);g.connect(this.m);o.start();o.stop(this.ctx.currentTime+d)},
noise(d,v){this.go();const b=this.ctx.createBuffer(1,this.ctx.sampleRate*d,this.ctx.sampleRate);const dd=b.getChannelData(0);let val=0;for(let i=0;i<dd.length;i++){val+=(Math.random()*2-1)*0.1;val*=0.98;dd[i]=val}const s=this.ctx.createBufferSource(),g=this.ctx.createGain();s.buffer=b;g.gain.setValueAtTime(v||0.15,this.ctx.currentTime);g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+d);s.connect(g);g.connect(this.m);s.start()},
play(n){const fx={
jump:()=>this.tone(380,.12,'square',[600,220]),
attack:()=>{this.noise(.12,.12);this.tone(200,.08,'sawtooth',[100])},
coin:()=>this.tone(1200,.12,'sine',[1800],.12),
hit:()=>this.noise(.15,.2),
kill:()=>{this.noise(.3,.15);this.tone(600,.15,'sine',[200])},
dash:()=>this.tone(300,.08,'sawtooth',[800,300],.06),
rune:()=>{[440,660,880,1100].forEach((f,i)=>setTimeout(()=>this.tone(f,.12,'sine',[],.08),i*80))},
runeOk:()=>{[523,659,784,1047].forEach((f,i)=>setTimeout(()=>this.tone(f,.15,'triangle',[],.1),i*100))},
runeFail:()=>{this.tone(200,.3,'sawtooth',[100],.1)},
lvlup:()=>{[440,554,659,880].forEach((f,i)=>setTimeout(()=>this.tone(f,.15,'square',[],.1),i*120))},
portal:()=>this.tone(440,.6,'sine',[880,440,880],.06),
heal:()=>this.tone(660,.2,'sine',[880,1100],.08),
draw:()=>this.tone(800+Math.random()*400,.06,'sine',[],.03)
};if(fx[n])fx[n]()},
musicI:null,
startMusic(){this.go();const mel=[261.63,293.66,329.63,349.23,392,440,493.88,523.25];let i=0;this.musicI=setInterval(()=>{const f=mel[i%mel.length];this.tone(f,.3,'triangle',[],.025);if(i%4===0)this.tone(f/2,.35,'sine',[],.015);i++},380)},
stopMusic(){if(this.musicI){clearInterval(this.musicI);this.musicI=null}}
};

// ==================== PARTICLES ====================
class Particles{
constructor(){this.list=[]}
emit(x,y,c){const n=c.count||1;for(let i=0;i<n;i++)this.list.push({x:x+(Math.random()-.5)*(c.spread||0),y:y+(Math.random()-.5)*(c.spread||0),vx:(Math.random()-.5)*(c.speed||4),vy:(c.vy!=null?c.vy:(Math.random()-.5))*(c.speed||4),life:c.life||30,maxLife:c.life||30,size:c.size||3,color:c.color||'#fff',grav:c.grav||0,drag:c.drag||0.98,glow:c.glow||false})}
update(){this.list=this.list.filter(p=>{p.vx*=p.drag;p.vy*=p.drag;p.vy+=p.grav;p.x+=p.vx;p.y+=p.vy;p.life--;return p.life>0})}
draw(ctx){this.list.forEach(p=>{const a=p.life/p.maxLife;ctx.globalAlpha=a;if(p.glow){ctx.shadowColor=p.color;ctx.shadowBlur=8}ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y,p.size*a,0,Math.PI*2);ctx.fill();ctx.shadowBlur=0});ctx.globalAlpha=1}
}

// ==================== RUNE SYSTEM ====================
// The core mechanic: players draw shapes that are matched against target runes
const RuneShapes = {
  // Each rune is defined as a series of normalized points (0-1 range)
  // The system samples points along the drawing and compares to these
  
  generateTargetRune(level) {
    // Different rune shapes per level - gets more complex
    const runes = [
      // Level 1: Simple triangle (easy)
      { name: 'RUNA IGNIS', desc: 'Desenhe um triangulo - o simbolo do fogo primordial',
        shape: 'triangle', points: [[0.5,0.1],[0.1,0.9],[0.9,0.9],[0.5,0.1]], color: '#ff6633' },
      // Level 2: Square 
      { name: 'RUNA TERRA', desc: 'Desenhe um quadrado - a fundacao da terra',
        shape: 'square', points: [[0.15,0.15],[0.85,0.15],[0.85,0.85],[0.15,0.85],[0.15,0.15]], color: '#44aa33' },
      // Level 3: Circle
      { name: 'RUNA AQUA', desc: 'Desenhe um circulo - o fluxo infinito da agua',
        shape: 'circle', color: '#3388ff' },
      // Level 4: Star (5 pointed)
      { name: 'RUNA STELLA', desc: 'Desenhe uma estrela de 5 pontas - poder celestial',
        shape: 'star', color: '#ffd700' },
      // Level 5: Zigzag lightning
      { name: 'RUNA FULMEN', desc: 'Desenhe um raio - o poder do trovao',
        shape: 'zigzag', points: [[0.3,0.05],[0.55,0.35],[0.35,0.4],[0.7,0.95]], color: '#ffee44' },
      // Level 6: Diamond 
      { name: 'RUNA VENTUS', desc: 'Desenhe um losango - as correntes do vento',
        shape: 'diamond', points: [[0.5,0.05],[0.95,0.5],[0.5,0.95],[0.05,0.5],[0.5,0.05]], color: '#66ddff' },
      // Level 7: Spiral
      { name: 'RUNA TEMPUS', desc: 'Desenhe uma espiral - a distorcao do tempo',
        shape: 'spiral', color: '#cc44ff' },
      // Level 8: Heart
      { name: 'RUNA VITA', desc: 'Desenhe um coracao - a essencia da vida',
        shape: 'heart', color: '#ff3366' },
      // Level 9: Infinity
      { name: 'RUNA INFINITUM', desc: 'Desenhe o infinito - o poder sem fim',
        shape: 'infinity', color: '#ffffff' },
      // Level 10: Pentagram
      { name: 'RUNA ARCANUM', desc: 'Desenhe um pentagrama - o segredo supremo',
        shape: 'pentagram', color: '#ff00ff' },
    ];
    return runes[(level - 1) % runes.length];
  },

  getTargetPoints(shape, size) {
    const s = size || 160;
    const cx = s/2, cy = s/2, r = s*0.4;
    const pts = [];
    
    if (shape === 'triangle') {
      const tri = [[cx,cy-r],[cx-r*0.87,cy+r*0.5],[cx+r*0.87,cy+r*0.5],[cx,cy-r]];
      for(let i=0;i<tri.length-1;i++){const a=tri[i],b=tri[i+1];for(let t=0;t<=1;t+=0.05)pts.push([a[0]+(b[0]-a[0])*t,a[1]+(b[1]-a[1])*t])}
    } else if (shape === 'square') {
      const sq = [[cx-r,cy-r],[cx+r,cy-r],[cx+r,cy+r],[cx-r,cy+r],[cx-r,cy-r]];
      for(let i=0;i<sq.length-1;i++){const a=sq[i],b=sq[i+1];for(let t=0;t<=1;t+=0.05)pts.push([a[0]+(b[0]-a[0])*t,a[1]+(b[1]-a[1])*t])}
    } else if (shape === 'circle') {
      for(let a=0;a<=Math.PI*2;a+=0.1)pts.push([cx+Math.cos(a)*r,cy+Math.sin(a)*r]);
    } else if (shape === 'star') {
      for(let i=0;i<5;i++){const a1=-Math.PI/2+i*Math.PI*2/5;const a2=-Math.PI/2+(i+0.5)*Math.PI*2/5;
      pts.push([cx+Math.cos(a1)*r,cy+Math.sin(a1)*r]);pts.push([cx+Math.cos(a2)*r*0.4,cy+Math.sin(a2)*r*0.4])}
      pts.push(pts[0]);
    } else if (shape === 'zigzag') {
      const zz=[[cx-r*0.4,cy-r],[cx+r*0.2,cy-r*0.2],[cx-r*0.3,cy+r*0.1],[cx+r*0.5,cy+r]];
      for(let i=0;i<zz.length-1;i++){const a=zz[i],b=zz[i+1];for(let t=0;t<=1;t+=0.05)pts.push([a[0]+(b[0]-a[0])*t,a[1]+(b[1]-a[1])*t])}
    } else if (shape === 'diamond') {
      const dm=[[cx,cy-r],[cx+r,cy],[cx,cy+r],[cx-r,cy],[cx,cy-r]];
      for(let i=0;i<dm.length-1;i++){const a=dm[i],b=dm[i+1];for(let t=0;t<=1;t+=0.05)pts.push([a[0]+(b[0]-a[0])*t,a[1]+(b[1]-a[1])*t])}
    } else if (shape === 'spiral') {
      for(let a=0;a<Math.PI*4;a+=0.12){const sr=r*0.15+r*0.85*(a/(Math.PI*4));pts.push([cx+Math.cos(a)*sr*0.6,cy+Math.sin(a)*sr*0.6])}
    } else if (shape === 'heart') {
      for(let a=0;a<=Math.PI*2;a+=0.08){const x=r*0.65*16*Math.pow(Math.sin(a),3);const y=-r*0.65*(13*Math.cos(a)-5*Math.cos(2*a)-2*Math.cos(3*a)-Math.cos(4*a));pts.push([cx+x/16,cy+y/16])}
    } else if (shape === 'infinity') {
      for(let a=0;a<=Math.PI*2;a+=0.08){const sc=r*0.7;const x=sc*Math.cos(a)/(1+Math.sin(a)*Math.sin(a));const y=sc*Math.sin(a)*Math.cos(a)/(1+Math.sin(a)*Math.sin(a));pts.push([cx+x,cy+y])}
    } else if (shape === 'pentagram') {
      const order=[0,2,4,1,3,0];
      for(let i=0;i<order.length-1;i++){const a1=-Math.PI/2+order[i]*Math.PI*2/5;const a2=-Math.PI/2+order[i+1]*Math.PI*2/5;
      const p1=[cx+Math.cos(a1)*r,cy+Math.sin(a1)*r];const p2=[cx+Math.cos(a2)*r,cy+Math.sin(a2)*r];
      for(let t=0;t<=1;t+=0.04)pts.push([p1[0]+(p2[0]-p1[0])*t,p1[1]+(p2[1]-p1[1])*t])}
    }
    return pts;
  },

  // Compare user drawing to target using grid sampling
  compareDrawings(userPoints, targetShape, canvasSize) {
    if (userPoints.length < 10) return 0;
    
    const gridSize = 16;
    const cellSize = canvasSize / gridSize;
    
    // Create grid representations
    const userGrid = Array.from({length:gridSize}, ()=>Array(gridSize).fill(0));
    const targetGrid = Array.from({length:gridSize}, ()=>Array(gridSize).fill(0));
    
    // Fill user grid
    userPoints.forEach(p => {
      const gx = Math.floor(p[0] / cellSize);
      const gy = Math.floor(p[1] / cellSize);
      if (gx >= 0 && gx < gridSize && gy >= 0 && gy < gridSize) userGrid[gy][gx] = 1;
    });
    
    // Fill target grid
    const targetPts = this.getTargetPoints(targetShape, canvasSize);
    targetPts.forEach(p => {
      const gx = Math.floor(p[0] / cellSize);
      const gy = Math.floor(p[1] / cellSize);
      if (gx >= 0 && gx < gridSize && gy >= 0 && gy < gridSize) targetGrid[gy][gx] = 1;
    });
    
    // Also fill nearby cells for tolerance
    const expandGrid = (grid) => {
      const g2 = grid.map(r=>[...r]);
      for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){
        if(grid[y][x]){
          if(x>0)g2[y][x-1]=1;if(x<gridSize-1)g2[y][x+1]=1;
          if(y>0)g2[y-1][x]=1;if(y<gridSize-1)g2[y+1][x]=1;
        }
      }
      return g2;
    };
    
    const expandedTarget = expandGrid(targetGrid);
    const expandedUser = expandGrid(userGrid);
    
    // Calculate match: how much of the target is covered + how much user stays within target
    let targetCells = 0, coveredCells = 0, userCells = 0, inTargetCells = 0;
    
    for(let y=0;y<gridSize;y++){
      for(let x=0;x<gridSize;x++){
        if(expandedTarget[y][x]) { targetCells++; if(userGrid[y][x]) coveredCells++; }
        if(userGrid[y][x]) { userCells++; if(expandedTarget[y][x]) inTargetCells++; }
      }
    }
    
    if (targetCells === 0 || userCells === 0) return 0;
    
    const coverage = coveredCells / targetCells; // how much of target is drawn
    const precision = inTargetCells / userCells; // how much of drawing is on target
    
    // Weighted score
    return Math.round(Math.min(100, (coverage * 0.6 + precision * 0.4) * 120));
  }
};

// ==================== MAIN GAME ====================
class Game {
  constructor() {
    this.canvas = document.getElementById('gc');
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize', () => this.resize());
    
    this.state = 'menu';
    this.frame = 0;
    this.particles = new Particles();
    this.player = null;
    this.world = null;
    this.camera = {x:0,y:0};
    this.shake = 0;
    this.screenFlash = 0;
    this.combo = 0;
    this.comboTimer = 0;
    
    // Input
    this.keys = {};
    this.setupInput();
    
    // Rune drawing
    this.runeDrawing = false;
    this.runePoints = [];
    this.runeCtx = null;
    this.currentRune = null;
    this.setupRuneCanvas();
    
    // Audio
    document.addEventListener('click', () => SFX.go(), {once:true});
    document.addEventListener('keydown', () => SFX.go(), {once:true});
    
    // Generate backgrounds
    this.bgStars = this.genStars();
    this.bgMountains = this.genMountains();
    this.bgCrystals = this.genCrystals();
    
    // Start
    requestAnimationFrame(t => this.loop(t));
    this.lastTime = 0;
  }
  
  resize() {
    this.W = window.innerWidth;
    this.H = window.innerHeight;
    this.canvas.width = this.W;
    this.canvas.height = this.H;
    this.scale = Math.min(this.W / 1024, this.H / 768);
  }
  
  setupInput() {
    window.addEventListener('keydown', e => {
      this.keys[e.code] = true;
      if (this.state === 'playing') {
        if (e.code === 'KeyJ') this.playerAttack();
        if (e.code === 'KeyK') this.playerDash();
      }
    });
    window.addEventListener('keyup', e => { this.keys[e.code] = false; });
  }
  
  // ===== RUNE CANVAS SETUP =====
  setupRuneCanvas() {
    const rc = document.getElementById('runeCanvas');
    this.runeCtx = rc.getContext('2d');
    let drawing = false;
    
    const getPos = (e) => {
      const rect = rc.getBoundingClientRect();
      const scaleX = 360 / rect.width;
      const scaleY = 360 / rect.height;
      const touch = e.touches ? e.touches[0] : e;
      return [
        (touch.clientX - rect.left) * scaleX,
        (touch.clientY - rect.top) * scaleY
      ];
    };
    
    const startDraw = (e) => {
      e.preventDefault();
      drawing = true;
      const p = getPos(e);
      this.runePoints.push(p);
      this.drawRuneStroke();
    };
    
    const moveDraw = (e) => {
      e.preventDefault();
      if (!drawing) return;
      const p = getPos(e);
      this.runePoints.push(p);
      this.drawRuneStroke();
      // Live match update
      if (this.runePoints.length % 5 === 0) this.updateRuneMatch();
      if (this.runePoints.length % 3 === 0) SFX.play('draw');
    };
    
    const endDraw = (e) => {
      e.preventDefault();
      drawing = false;
      this.updateRuneMatch();
    };
    
    rc.addEventListener('mousedown', startDraw);
    rc.addEventListener('mousemove', moveDraw);
    rc.addEventListener('mouseup', endDraw);
    rc.addEventListener('mouseleave', endDraw);
    rc.addEventListener('touchstart', startDraw, {passive:false});
    rc.addEventListener('touchmove', moveDraw, {passive:false});
    rc.addEventListener('touchend', endDraw, {passive:false});
  }
  
  drawRuneStroke() {
    const ctx = this.runeCtx;
    const pts = this.runePoints;
    if (pts.length < 2) return;
    
    ctx.clearRect(0, 0, 360, 360);
    
    // Draw grid dots
    ctx.fillStyle = 'rgba(170,102,255,0.06)';
    for(let x = 0; x < 360; x += 30) for(let y = 0; y < 360; y += 30) {
      ctx.beginPath(); ctx.arc(x, y, 1, 0, Math.PI*2); ctx.fill();
    }
    
    // Main stroke with glow
    ctx.save();
    ctx.shadowColor = this.currentRune ? this.currentRune.color : '#aa66ff';
    ctx.shadowBlur = 12;
    ctx.strokeStyle = this.currentRune ? this.currentRune.color : '#aa66ff';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let i = 1; i < pts.length; i++) {
      ctx.lineTo(pts[i][0], pts[i][1]);
    }
    ctx.stroke();
    ctx.restore();
    
    // Particle sparkles along line
    ctx.fillStyle = '#fff';
    for (let i = Math.max(0, pts.length - 8); i < pts.length; i++) {
      if (Math.random() > 0.5) {
        ctx.globalAlpha = Math.random() * 0.6 + 0.2;
        ctx.beginPath();
        ctx.arc(pts[i][0] + (Math.random()-0.5)*10, pts[i][1] + (Math.random()-0.5)*10, Math.random()*2+0.5, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
  }
  
  updateRuneMatch() {
    if (!this.currentRune) return;
    const match = RuneShapes.compareDrawings(this.runePoints, this.currentRune.shape, 360);
    const el = document.getElementById('matchPct');
    el.textContent = match + '%';
    el.style.color = match >= 60 ? '#44ff88' : match >= 35 ? '#ffaa44' : '#ff4444';
    el.style.textShadow = match >= 60 ? '0 0 15px #44ff88' : 'none';
  }
  
  drawTargetRune() {
    if (!this.currentRune) return;
    const tc = document.getElementById('targetCanvas');
    const ctx = tc.getContext('2d');
    ctx.clearRect(0, 0, 160, 160);
    
    const pts = RuneShapes.getTargetPoints(this.currentRune.shape, 160);
    if (pts.length < 2) return;
    
    ctx.strokeStyle = this.currentRune.color;
    ctx.lineWidth = 2.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.shadowColor = this.currentRune.color;
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]);
    ctx.stroke();
  }
  
  // ===== RUNE OVERLAY =====
  showRuneChallenge() {
    this.state = 'rune';
    this.currentRune = RuneShapes.generateTargetRune(this.world.level);
    document.getElementById('runeTitle').textContent = this.currentRune.name;
    document.getElementById('runeDesc').textContent = this.currentRune.desc;
    document.getElementById('matchPct').textContent = '0%';
    document.getElementById('matchPct').style.color = '#ff4444';
    this.clearRune();
    this.drawTargetRune();
    document.getElementById('runeOverlay').classList.add('active');
    SFX.stopMusic();
    SFX.play('portal');
  }
  
  clearRune() {
    this.runePoints = [];
    this.runeCtx.clearRect(0, 0, 360, 360);
    // Draw grid dots
    this.runeCtx.fillStyle = 'rgba(170,102,255,0.06)';
    for(let x=0;x<360;x+=30)for(let y=0;y<360;y+=30){
      this.runeCtx.beginPath();this.runeCtx.arc(x,y,1,0,Math.PI*2);this.runeCtx.fill();
    }
    document.getElementById('matchPct').textContent = '0%';
    document.getElementById('matchPct').style.color = '#ff4444';
  }
  
  castRune() {
    if (!this.currentRune) return;
    const match = RuneShapes.compareDrawings(this.runePoints, this.currentRune.shape, 360);
    
    if (match >= 60) {
      SFX.play('runeOk');
      this.closeRune();
      
      const bonus = Math.floor((match - 60) * 5);
      const xpGain = 300 + bonus;
      this.player.xp += xpGain;
      this.player.runes++;
      
      this.showToast('RUNA CONJURADA!', `Precisao: ${match}% | +${xpGain} XP`);
      
      // Epic particle burst
      this.particles.emit(this.player.x + 32, this.player.y + 40, {
        count: 40, speed: 12, life: 50, color: this.currentRune.color, size: 5, glow: true, spread: 40
      });
      this.screenFlash = 15;
      this.shake = 12;
      
      this.checkLevelUp();
      
      // Advance to next level after delay
      setTimeout(() => {
        this.generateWorld(this.world.level + 1);
        this.player.x = 120;
        this.player.y = 400;
        this.player.vy = 0;
        this.player.hp = Math.min(this.player.hp + 30, this.player.maxHp);
        this.player.ink = this.player.maxInk;
        this.updateHUD();
      }, 1000);
      
      // Bonus: perfect match
      if (match >= 90) {
        this.showToast('PERFEITO!', 'Runa perfeita! +50 HP +500 XP extra!');
        this.player.xp += 500;
        this.player.hp = this.player.maxHp;
        this.checkLevelUp();
      }
    } else {
      SFX.play('runeFail');
      this.showToast('RUNA INSTAVEL', `Precisao: ${match}% - Precisa de 60% ou mais. Tente novamente!`);
      // Damage player for failed rune
      this.player.hp -= 10;
      this.player.ink -= 15;
      this.shake = 6;
      this.updateHUD();
      if (this.player.hp <= 0) {
        this.closeRune();
        this.gameOver();
      }
    }
  }
  
  closeRune() {
    document.getElementById('runeOverlay').classList.remove('active');
    this.state = 'playing';
    SFX.startMusic();
  }
  
  // ===== BACKGROUNDS =====
  genStars() {
    const c = document.createElement('canvas'); c.width = 1200; c.height = 800;
    const ctx = c.getContext('2d');
    for (let i = 0; i < 250; i++) {
      ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.7+0.1})`;
      const s = Math.random()*2+0.5;
      ctx.fillRect(Math.random()*1200, Math.random()*800, s, s);
    }
    // Nebula
    const g = ctx.createRadialGradient(400, 300, 20, 400, 300, 250);
    g.addColorStop(0, 'rgba(100,50,200,0.08)');
    g.addColorStop(1, 'transparent');
    ctx.fillStyle = g; ctx.fillRect(0,0,1200,800);
    const g2 = ctx.createRadialGradient(800, 500, 20, 800, 500, 200);
    g2.addColorStop(0, 'rgba(200,50,100,0.06)');
    g2.addColorStop(1, 'transparent');
    ctx.fillStyle = g2; ctx.fillRect(0,0,1200,800);
    return c;
  }
  
  genMountains() {
    const c = document.createElement('canvas'); c.width = 1200; c.height = 800;
    const ctx = c.getContext('2d');
    // Crystal mountains
    for (let i = 0; i < 10; i++) {
      const mx = i * 130 - 30;
      const mh = 150 + Math.random() * 200;
      const grad = ctx.createLinearGradient(0, 800-mh, 0, 800);
      grad.addColorStop(0, '#150830');
      grad.addColorStop(1, '#0a0418');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(mx, 800);
      ctx.lineTo(mx + 60, 800 - mh);
      ctx.lineTo(mx + 120, 800);
      ctx.fill();
      // Crystal tips glow
      ctx.fillStyle = `rgba(${100+Math.random()*100},${50+Math.random()*100},${200+Math.random()*55},0.3)`;
      ctx.beginPath();
      ctx.arc(mx + 60, 800 - mh, 4, 0, Math.PI*2);
      ctx.fill();
    }
    return c;
  }
  
  genCrystals() {
    const c = document.createElement('canvas'); c.width = 1200; c.height = 800;
    const ctx = c.getContext('2d');
    // Floating crystal structures
    for (let i = 0; i < 8; i++) {
      const x = 80 + i * 150;
      const y = 500 + Math.random() * 200;
      const h = 60 + Math.random() * 100;
      const grad = ctx.createLinearGradient(0, y-h, 0, y);
      grad.addColorStop(0, '#1a0a30');
      grad.addColorStop(1, '#0d0520');
      ctx.fillStyle = grad;
      ctx.fillRect(x, y-h, 30+Math.random()*20, h);
      // Windows/runes
      ctx.fillStyle = `rgba(${Math.random()>0.5?170:0},${Math.random()>0.5?102:229},255,0.4)`;
      for(let j=0;j<h/30;j++){
        if(Math.random()>0.4) ctx.fillRect(x+5, y-h+15+j*30, 4, 6);
      }
    }
    return c;
  }
  
  // ===== START GAME =====
  startGame() {
    document.getElementById('menuScreen').classList.add('hidden');
    document.getElementById('hud').style.display = 'block';
    SFX.startMusic();
    
    this.player = {
      x: 120, y: 400, vx: 0, vy: 0, w: 48, h: 64,
      hp: 100, maxHp: 100, ink: 100, maxInk: 100,
      lvl: 1, xp: 0, runes: 0,
      facing: 1, grounded: false,
      anim: 'idle', frame: 0, animTimer: 0,
      attacking: false, attackTimer: 0, attackCd: 0,
      dashing: false, dashTimer: 0, dashCd: 0, dashDir: 1,
      invincible: 0, jumps: 0, maxJumps: 2,
      trail: [], color: '#aa66ff'
    };
    
    this.generateWorld(1);
    this.state = 'playing';
  }
  
  generateWorld(level) {
    const worldW = 2800 + level * 300;
    this.world = { level, w: worldW, h: 900, platforms: [], enemies: [], items: [], portal: null };
    
    // Ground with gaps
    for (let x = 0; x < worldW; x += 32) {
      const gap = (x > 450 && x < 530) || (x > 1100 && x < 1200) || (x > 1800 && x < 1900) || (x > 2400 && x < 2480);
      if (!gap) this.world.platforms.push({x, y: 660, w: 32, h: 240, type: 'ground'});
    }
    
    // Floating platforms
    const pc = 8 + level * 2;
    for (let i = 0; i < pc; i++) {
      const px = 250 + i * (worldW - 400) / pc;
      const py = 350 + Math.sin(i * 1.5) * 140;
      const pw = 60 + Math.random() * 80;
      this.world.platforms.push({
        x: px, y: py, w: pw, h: 20, type: 'platform',
        moving: Math.random() > 0.65,
        moveY: py, moveRange: 35 + Math.random() * 50,
        moveSpeed: 0.4 + Math.random() * 0.4,
        movePhase: Math.random() * Math.PI * 2
      });
    }
    
    // Walls for wall-jumping
    for (let i = 0; i < 2 + Math.floor(level/2); i++) {
      const wx = 700 + i * 600;
      if (wx < worldW - 300) this.world.platforms.push({x: wx, y: 380, w: 20, h: 280, type: 'wall'});
    }
    
    // Enemies
    const eTypes = ['wisp','wisp','golem'];
    if (level >= 3) eTypes.push('drake');
    if (level >= 5) eTypes.push('shade');
    const eCount = 5 + level * 2;
    for (let i = 0; i < eCount; i++) {
      const t = eTypes[Math.floor(Math.random() * eTypes.length)];
      const ex = 300 + i * ((worldW - 500) / eCount);
      const hpMap = {wisp:25, golem:70, drake:100, shade:50};
      this.world.enemies.push({
        x: ex, y: 600, vx: 0, vy: 0, w: 36, h: 36,
        type: t, hp: (hpMap[t]||40) + level*5, maxHp: (hpMap[t]||40) + level*5,
        facing: -1, frame: 0, timer: 0,
        patrolA: ex - 50, patrolB: ex + 50,
        dead: false, deathTimer: 0,
        canShoot: t === 'drake', shootCd: 0,
        floatPhase: Math.random() * Math.PI * 2
      });
    }
    
    // Boss every 5 levels
    if (level % 5 === 0) {
      this.world.enemies.push({
        x: worldW - 350, y: 530, vx: 0, vy: 0, w: 60, h: 60,
        type: 'boss', hp: 250 + level*25, maxHp: 250 + level*25,
        facing: -1, frame: 0, timer: 0,
        patrolA: worldW - 450, patrolB: worldW - 280,
        dead: false, deathTimer: 0, canShoot: true, shootCd: 0,
        floatPhase: 0
      });
    }
    
    // Rune Crystals (collectibles)
    for (let i = 0; i < 20 + level * 2; i++) {
      this.world.items.push({
        x: 200 + Math.random() * (worldW - 400),
        y: 250 + Math.random() * 350,
        type: 'crystal', value: 10, collected: false, float: Math.random() * Math.PI * 2
      });
    }
    
    // Health orbs
    for (let i = 0; i < 2; i++) {
      this.world.items.push({
        x: 400 + Math.random() * (worldW - 600),
        y: 280 + Math.random() * 250,
        type: 'health', value: 25, collected: false, float: Math.random() * Math.PI * 2
      });
    }
    
    // Ink orbs
    for (let i = 0; i < 3; i++) {
      this.world.items.push({
        x: 350 + Math.random() * (worldW - 500),
        y: 300 + Math.random() * 200,
        type: 'ink', value: 30, collected: false, float: Math.random() * Math.PI * 2
      });
    }
    
    // Portal (the rune altar)
    this.world.portal = {x: worldW - 100, y: 580, w: 64, h: 80, active: true};
    
    this.updateHUD();
    document.getElementById('stageBadge').textContent = `REALM ${level}`;
  }
  
  // ===== PLAYER ACTIONS =====
  playerAttack() {
    if (this.player.attackCd > 0 || this.player.attacking) return;
    this.player.attacking = true;
    this.player.attackTimer = 14;
    this.player.attackCd = 18;
    SFX.play('attack');
    
    const range = 60;
    const px = this.player.x + this.player.w/2 + this.player.facing * 25;
    const py = this.player.y + this.player.h/2;
    
    // Emit attack particles
    this.particles.emit(px, py, {
      count: 6, speed: 5, life: 12, color: '#aa66ff', size: 3, glow: true, spread: 15
    });
    
    this.world.enemies.forEach(e => {
      if (e.dead) return;
      const dx = (e.x + e.w/2) - px;
      const dy = (e.y + e.h/2) - py;
      if (Math.abs(dx) < range && Math.abs(dy) < range) {
        this.damageEnemy(e, 18 + this.player.lvl * 2);
      }
    });
  }
  
  playerDash() {
    if (this.player.dashCd > 0 || this.player.dashing) return;
    this.player.dashing = true;
    this.player.dashTimer = 10;
    this.player.dashCd = 35;
    this.player.dashDir = this.player.facing;
    this.player.invincible = Math.max(this.player.invincible, 10);
    SFX.play('dash');
  }
  
  damageEnemy(e, dmg) {
    const crit = Math.random() < 0.15;
    const fd = crit ? dmg * 2 : dmg;
    e.hp -= fd;
    
    this.particles.emit(e.x+e.w/2, e.y+e.h/2, {
      count: 6, speed: 5, life: 15, color: crit ? '#ffd700' : '#ff2244', size: 3, grav: 0.2
    });
    
    this.combo++;
    this.comboTimer = 100;
    
    if (e.hp <= 0) {
      e.dead = true;
      e.deathTimer = 25;
      const xp = e.type === 'boss' ? 180 : e.type === 'drake' ? 45 : 20;
      this.player.xp += xp + this.combo * 2;
      this.shake = 6;
      this.particles.emit(e.x+e.w/2, e.y+e.h/2, {
        count: 20, speed: 8, life: 35, color: '#aa66ff', size: 5, grav: 0.3, glow: true
      });
      SFX.play('kill');
      this.checkLevelUp();
    } else {
      e.vx = (e.x > this.player.x ? 3 : -3);
      SFX.play('hit');
    }
    this.updateHUD();
  }
  
  checkLevelUp() {
    const needed = this.player.lvl * 100;
    if (this.player.xp >= needed) {
      this.player.lvl++;
      this.player.xp -= needed;
      this.player.maxHp += 12;
      this.player.hp = this.player.maxHp;
      this.player.maxInk += 8;
      this.player.ink = this.player.maxInk;
      this.player.maxJumps = this.player.lvl >= 4 ? 3 : 2;
      
      document.getElementById('newLvl').textContent = this.player.lvl;
      document.getElementById('lvlBanner').classList.add('show');
      setTimeout(() => document.getElementById('lvlBanner').classList.remove('show'), 2000);
      
      SFX.play('lvlup');
      this.showToast('LEVEL UP!', `Nivel ${this.player.lvl}! +HP +Tinta`);
      this.particles.emit(this.player.x+24, this.player.y+32, {
        count: 25, speed: 7, life: 40, color: '#00ccaa', size: 4, glow: true, spread: 30
      });
    }
    this.updateHUD();
  }
  
  showToast(title, text) {
    document.getElementById('toastTitle').textContent = title;
    document.getElementById('toastText').textContent = text;
    const t = document.getElementById('toast');
    t.classList.add('show');
    setTimeout(() => t.classList.remove('show'), 3000);
  }
  
  updateHUD() {
    const P = this.player;
    if (!P) return;
    document.getElementById('hpBar').style.width = (P.hp/P.maxHp*100)+'%';
    document.getElementById('hpText').textContent = `${Math.floor(P.hp)}/${P.maxHp}`;
    document.getElementById('inkBar').style.width = (P.ink/P.maxInk*100)+'%';
    document.getElementById('inkText').textContent = `${Math.floor(P.ink)}/${P.maxInk}`;
    const needed = P.lvl * 100;
    document.getElementById('xpBar').style.width = (P.xp/needed*100)+'%';
    document.getElementById('xpText').textContent = `LVL ${P.lvl}`;
    document.getElementById('runesVal').textContent = P.runes;
  }
  
  // ===== UPDATE =====
  update() {
    if (this.state !== 'playing') return;
    this.frame++;
    
    const P = this.player;
    const spd = 0.65, maxSpd = 6.5, fric = 0.83;
    
    // Movement
    if (this.keys['KeyA'] || this.keys['ArrowLeft']) { P.vx -= spd; P.facing = -1; }
    else if (this.keys['KeyD'] || this.keys['ArrowRight']) { P.vx += spd; P.facing = 1; }
    else { P.vx *= fric; if (Math.abs(P.vx) < 0.3) P.vx = 0; }
    P.vx = Math.max(-maxSpd, Math.min(maxSpd, P.vx));
    
    // Dash
    if (P.dashing) {
      P.vx = P.dashDir * 16;
      P.dashTimer--;
      if (P.dashTimer <= 0) P.dashing = false;
      P.trail.push({x: P.x, y: P.y, alpha: 0.6});
    }
    P.trail = P.trail.filter(t => { t.alpha -= 0.05; return t.alpha > 0; });
    
    // Jump
    if ((this.keys['Space'] || this.keys['ArrowUp'] || this.keys['KeyW']) && P.jumps < P.maxJumps) {
      if (!this._jh) {
        P.vy = P.jumps === 0 ? -13 : -10;
        P.jumps++;
        P.grounded = false;
        SFX.play('jump');
        this.particles.emit(P.x+P.w/2, P.y+P.h, {count: 6, speed: 2.5, life: 12, color: '#555', size: 2, grav: 0.15});
        if (P.wallSliding) { P.vx = -P.facing * 7; P.facing *= -1; }
        this._jh = true;
      }
    } else { this._jh = false; }
    
    // Gravity
    P.vy += 0.65;
    
    // Wall slide
    P.wallSliding = false;
    if (!P.grounded && P.vy > 0) {
      this.world.platforms.forEach(pl => {
        if (pl.type !== 'wall') return;
        if (P.x+P.w > pl.x && P.x < pl.x+pl.w && P.y+P.h > pl.y && P.y < pl.y+pl.h) {
          P.wallSliding = true;
          P.vy = Math.min(P.vy, 1.8);
          P.jumps = 1;
        }
      });
    }
    
    // Apply velocity
    P.x += P.vx;
    P.y += P.vy;
    
    // Platform collision
    P.grounded = false;
    this.world.platforms.forEach(pl => {
      if (pl.type === 'wall') return;
      if (pl.moving) pl.y = pl.moveY + Math.sin(this.frame * 0.02 * pl.moveSpeed + pl.movePhase) * pl.moveRange;
      if (P.x+P.w > pl.x && P.x < pl.x+pl.w && P.y+P.h > pl.y && P.y+P.h < pl.y+pl.h+16 && P.vy >= 0) {
        P.y = pl.y - P.h;
        P.vy = 0;
        P.grounded = true;
        P.jumps = 0;
        if (pl.moving) P.x += Math.cos(this.frame*0.02*pl.moveSpeed+pl.movePhase)*pl.moveRange*0.02*pl.moveSpeed;
      }
    });
    
    // World bounds
    P.x = Math.max(0, Math.min(P.x, this.world.w - P.w));
    if (P.y > 900) { P.y = 400; P.vy = 0; P.hp -= 18; this.shake = 10; SFX.play('hit'); this.updateHUD(); }
    
    // Attack timer
    if (P.attacking) { P.attackTimer--; if (P.attackTimer <= 0) P.attacking = false; }
    if (P.attackCd > 0) P.attackCd--;
    if (P.dashCd > 0) P.dashCd--;
    if (P.invincible > 0) P.invincible--;
    
    // Anim
    P.animTimer++;
    if (P.animTimer >= 6) { P.animTimer = 0; P.frame = (P.frame + 1) % 4; }
    
    // Run particles
    if (Math.abs(P.vx) > 2 && P.grounded && this.frame % 5 === 0) {
      this.particles.emit(P.x+P.w/2, P.y+P.h, {count: 1, speed: 1.2, life: 10, color: '#444', size: 2, grav: 0.1, vy: -0.4});
    }
    
    // Enemies
    this.world.enemies.forEach(e => {
      if (e.dead) { e.deathTimer--; return; }
      if (e.x <= e.patrolA) e.facing = 1;
      if (e.x >= e.patrolB) e.facing = -1;
      e.x += e.facing * (e.type === 'boss' ? 1 : e.type === 'golem' ? 0.7 : 1.3);
      e.floatPhase += 0.03;
      
      const dist = Math.abs(e.x - P.x);
      if (dist < 180 && e.type !== 'wisp') { e.facing = P.x > e.x ? 1 : -1; e.x += e.facing * 0.4; }
      
      e.vx *= 0.9;
      e.x += e.vx;
      e.timer++;
      if (e.timer > 10) { e.timer = 0; e.frame = (e.frame+1) % 4; }
      
      // Shooting
      if (e.canShoot && dist < 280) {
        e.shootCd--;
        if (e.shootCd <= 0) {
          e.shootCd = e.type === 'boss' ? 35 : 70;
          this.world.items.push({
            x: e.x+e.w/2, y: e.y+e.h/2,
            type: 'projectile', vx: e.facing * 4.5, life: 70,
            collected: false, float: 0
          });
        }
      }
      
      // Collision with player
      if (P.invincible <= 0 && P.x+P.w > e.x+3 && P.x+3 < e.x+e.w && P.y+P.h > e.y+3 && P.y+3 < e.y+e.h) {
        if (P.vy > 0 && P.y+P.h < e.y+e.h/2) {
          this.damageEnemy(e, 25 + P.lvl*3);
          P.vy = -10;
        } else if (!P.dashing) {
          const dmg = e.type === 'boss' ? 22 : 12;
          P.hp -= dmg;
          P.invincible = 45;
          P.vx = (P.x < e.x ? -7 : 7);
          P.vy = -4;
          this.shake = 8;
          SFX.play('hit');
          this.screenFlash = 5;
          this.updateHUD();
          if (P.hp <= 0) this.gameOver();
        }
      }
    });
    
    // Items
    this.world.items.forEach(item => {
      if (item.collected) return;
      if (item.type === 'projectile') {
        item.x += item.vx;
        item.life--;
        if (item.life <= 0) { item.collected = true; return; }
        if (P.invincible <= 0 && Math.abs(item.x-(P.x+P.w/2))<18 && Math.abs(item.y-(P.y+P.h/2))<28) {
          P.hp -= 8;
          P.invincible = 25;
          item.collected = true;
          this.shake = 4;
          SFX.play('hit');
          this.updateHUD();
          if (P.hp <= 0) this.gameOver();
        }
        return;
      }
      
      item.float += 0.04;
      const fy = item.y + Math.sin(item.float) * 5;
      
      if (P.x+P.w > item.x-4 && P.x-4 < item.x+20 && P.y+P.h > fy-4 && P.y-4 < fy+20) {
        item.collected = true;
        if (item.type === 'crystal') {
          P.xp += item.value;
          SFX.play('coin');
          this.particles.emit(item.x+10, fy+10, {count: 6, speed: 3.5, life: 18, color: '#aa66ff', size: 3, glow: true});
          this.checkLevelUp();
        } else if (item.type === 'health') {
          P.hp = Math.min(P.hp + item.value, P.maxHp);
          SFX.play('heal');
          this.particles.emit(item.x+10, fy+10, {count: 8, speed: 3, life: 18, color: '#ff3366', size: 3, glow: true});
        } else if (item.type === 'ink') {
          P.ink = Math.min(P.ink + item.value, P.maxInk);
          SFX.play('coin');
          this.particles.emit(item.x+10, fy+10, {count: 8, speed: 3, life: 18, color: '#aa66ff', size: 3, glow: true});
        }
        this.updateHUD();
      }
    });
    
    // Ink regen
    if (this.frame % 10 === 0 && P.ink < P.maxInk) { P.ink += 0.5; this.updateHUD(); }
    
    // Combo timer
    if (this.comboTimer > 0) this.comboTimer--;
    else this.combo = 0;
    
    // Particles
    this.particles.update();
    
    // Camera
    const tx = P.x - this.W/this.scale/2 + P.w/2;
    const ty = P.y - this.H/this.scale/2 + P.h/2;
    this.camera.x += (tx - this.camera.x) * 0.08;
    this.camera.y += (ty - this.camera.y) * 0.06;
    this.camera.x = Math.max(0, Math.min(this.camera.x, this.world.w - this.W/this.scale));
    this.camera.y = Math.max(-100, Math.min(this.camera.y, 300));
    
    if (this.shake > 0.3) this.shake *= 0.88; else this.shake = 0;
    if (this.screenFlash > 0) this.screenFlash--;
    
    // Portal collision
    const port = this.world.portal;
    if (port.active && P.x+P.w > port.x && P.x < port.x+port.w && P.y+P.h > port.y && P.y < port.y+port.h) {
      this.showRuneChallenge();
    }
  }
  
  // ===== DRAW =====
  draw() {
    const ctx = this.ctx;
    const W = this.W, H = this.H;
    
    // Deep background
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, '#05020f');
    bgGrad.addColorStop(0.5, '#0a0520');
    bgGrad.addColorStop(1, '#080318');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);
    
    if (this.state !== 'playing' && this.state !== 'rune' && this.state !== 'paused') return;
    
    ctx.save();
    const s = this.scale;
    const ox = (W - 1024*s)/2;
    const oy = (H - 768*s)/2;
    
    let sx = 0, sy = 0;
    if (this.shake > 0.3) { sx = (Math.random()-0.5)*this.shake; sy = (Math.random()-0.5)*this.shake; }
    
    ctx.translate(ox+sx*s, oy+sy*s);
    ctx.scale(s, s);
    
    // Parallax backgrounds
    const px1 = -(this.camera.x*0.05)%1200;
    ctx.drawImage(this.bgStars, px1, 0);
    ctx.drawImage(this.bgStars, px1+1200, 0);
    
    const px2 = -(this.camera.x*0.15)%1200;
    ctx.drawImage(this.bgMountains, px2, 0);
    ctx.drawImage(this.bgMountains, px2+1200, 0);
    
    const px3 = -(this.camera.x*0.3)%1200;
    ctx.drawImage(this.bgCrystals, px3, 0);
    ctx.drawImage(this.bgCrystals, px3+1200, 0);
    
    ctx.save();
    ctx.translate(-this.camera.x, -this.camera.y);
    
    // ---- PLATFORMS ----
    this.world.platforms.forEach(pl => {
      if (pl.x+pl.w < this.camera.x-50 || pl.x > this.camera.x+W/s+50) return;
      
      if (pl.type === 'ground') {
        // Magical earth
        ctx.fillStyle = '#1a0d2e';
        ctx.fillRect(pl.x, pl.y, pl.w, pl.h);
        // Top glow
        const topG = ctx.createLinearGradient(0, pl.y, 0, pl.y+8);
        topG.addColorStop(0, '#4a2a6a');
        topG.addColorStop(1, '#1a0d2e');
        ctx.fillStyle = topG;
        ctx.fillRect(pl.x, pl.y, pl.w, 8);
        // Crystal shards on top
        if (pl.x % 96 < 32) {
          ctx.fillStyle = 'rgba(170,102,255,0.3)';
          ctx.beginPath();
          ctx.moveTo(pl.x+8, pl.y);
          ctx.lineTo(pl.x+12, pl.y-10);
          ctx.lineTo(pl.x+16, pl.y);
          ctx.fill();
        }
      } else if (pl.type === 'platform') {
        const pGrad = ctx.createLinearGradient(0, pl.y, 0, pl.y+pl.h);
        pGrad.addColorStop(0, '#2a1a44');
        pGrad.addColorStop(1, '#150d28');
        ctx.fillStyle = pGrad;
        ctx.fillRect(pl.x, pl.y, pl.w, pl.h);
        ctx.fillStyle = pl.moving ? '#ff3366' : '#aa66ff';
        ctx.fillRect(pl.x, pl.y, pl.w, 2);
        // Rune glow
        ctx.fillStyle = 'rgba(170,102,255,0.1)';
        ctx.fillRect(pl.x+4, pl.y+6, pl.w-8, 1);
      } else if (pl.type === 'wall') {
        ctx.fillStyle = '#1a1030';
        ctx.fillRect(pl.x, pl.y, pl.w, pl.h);
        ctx.fillStyle = 'rgba(170,102,255,0.12)';
        for(let i=0;i<pl.h/18;i++) ctx.fillRect(pl.x+3, pl.y+i*18+3, pl.w-6, 1);
      }
    });
    
    // ---- PORTAL (Rune Altar) ----
    const port = this.world.portal;
    const pulse = Math.sin(this.frame*0.04)*0.3+0.7;
    
    // Altar base
    ctx.fillStyle = '#2a1a40';
    ctx.fillRect(port.x-10, port.y+50, port.w+20, 30);
    ctx.fillStyle = '#3a2a55';
    ctx.fillRect(port.x-5, port.y+45, port.w+10, 10);
    
    // Rune circle
    ctx.save();
    ctx.translate(port.x+32, port.y+25);
    ctx.rotate(this.frame*0.01);
    
    // Outer ring
    ctx.strokeStyle = `rgba(170,102,255,${pulse*0.6})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 35, 0, Math.PI*2);
    ctx.stroke();
    
    // Inner ring
    ctx.strokeStyle = `rgba(255,102,200,${pulse*0.4})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, 22, 0, Math.PI*2);
    ctx.stroke();
    
    // Rune symbols rotating
    ctx.fillStyle = `rgba(170,102,255,${pulse})`;
    for(let i=0;i<6;i++){
      const a = i*Math.PI/3;
      ctx.fillRect(Math.cos(a)*28-2, Math.sin(a)*28-2, 4, 4);
    }
    
    ctx.restore();
    
    // Portal glow
    const pGrad = ctx.createRadialGradient(port.x+32, port.y+25, 0, port.x+32, port.y+25, 50);
    pGrad.addColorStop(0, `rgba(170,102,255,${pulse*0.25})`);
    pGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = pGrad;
    ctx.fillRect(port.x-20, port.y-30, 104, 110);
    
    // Portal particles
    if (this.frame % 3 === 0) {
      this.particles.emit(port.x+32, port.y+25, {
        count: 1, speed: 1.5, life: 25, color: Math.random()>0.5 ? '#aa66ff' : '#ff66cc', size: 2, glow: true
      });
    }
    
    // Text "DRAW" indicator
    ctx.fillStyle = `rgba(170,102,255,${0.4+Math.sin(this.frame*0.06)*0.3})`;
    ctx.font = '9px Orbitron, monospace';
    ctx.textAlign = 'center';
    ctx.fillText('DESENHE', port.x+32, port.y-10);
    ctx.textAlign = 'left';
    
    // ---- ITEMS ----
    this.world.items.forEach(item => {
      if (item.collected) return;
      if (item.type === 'projectile') {
        ctx.fillStyle = '#ff4400';
        ctx.shadowColor = '#ff4400';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(item.x, item.y, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        return;
      }
      
      const fy = item.y + Math.sin(item.float)*5;
      
      if (item.type === 'crystal') {
        // Floating crystal
        ctx.save();
        ctx.translate(item.x+8, fy+8);
        ctx.rotate(Math.sin(item.float*0.5)*0.2);
        ctx.fillStyle = '#bb77ff';
        ctx.shadowColor = '#aa66ff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(0, -7);
        ctx.lineTo(5, 0);
        ctx.lineTo(0, 7);
        ctx.lineTo(-5, 0);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#ddaaff';
        ctx.beginPath();
        ctx.moveTo(-1, -4);
        ctx.lineTo(2, 0);
        ctx.lineTo(-1, 2);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
      } else if (item.type === 'health') {
        ctx.fillStyle = '#ff3366';
        ctx.shadowColor = '#ff3366';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        // Heart shape
        const hx = item.x+8, hy = fy+8;
        ctx.moveTo(hx, hy+6);
        ctx.bezierCurveTo(hx-8, hy, hx-8, hy-6, hx, hy-3);
        ctx.bezierCurveTo(hx+8, hy-6, hx+8, hy, hx, hy+6);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (item.type === 'ink') {
        ctx.fillStyle = '#6633ff';
        ctx.shadowColor = '#6633ff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(item.x+8, fy+8, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#aa88ff';
        ctx.beginPath();
        ctx.arc(item.x+6, fy+6, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    });
    
    // ---- ENEMIES ----
    this.world.enemies.forEach(e => {
      if (e.dead && e.deathTimer <= 0) return;
      if (e.dead) { ctx.globalAlpha = e.deathTimer/25; }
      
      const ex = e.x, ey = e.y + Math.sin(e.floatPhase)*3;
      
      if (e.type === 'wisp') {
        // Magical wisp - glowing orb
        const wobble = Math.sin(this.frame*0.08+e.floatPhase)*2;
        ctx.fillStyle = '#39ff14';
        ctx.shadowColor = '#39ff14';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(ex+e.w/2+wobble, ey+e.h/2, 12+Math.sin(this.frame*0.06)*2, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#88ff66';
        ctx.beginPath();
        ctx.arc(ex+e.w/2+wobble-3, ey+e.h/2-3, 4, 0, Math.PI*2);
        ctx.fill();
        // Eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(ex+e.w/2-4+wobble, ey+e.h/2-1, 2, 0, Math.PI*2);
        ctx.arc(ex+e.w/2+4+wobble, ey+e.h/2-1, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (e.type === 'golem') {
        // Stone golem
        ctx.fillStyle = '#556677';
        ctx.fillRect(ex+4, ey+4, e.w-8, e.h-8);
        ctx.fillStyle = '#778899';
        ctx.fillRect(ex+6, ey+6, e.w-12, 8);
        // Eyes
        ctx.fillStyle = '#ff4400';
        ctx.fillRect(ex+10, ey+10, 4, 4);
        ctx.fillRect(ex+22, ey+10, 4, 4);
        // Arms
        ctx.fillStyle = '#445566';
        const armOff = e.frame%2 ? 2 : 0;
        ctx.fillRect(ex, ey+10+armOff, 6, 14);
        ctx.fillRect(ex+e.w-6, ey+10+(e.frame%2?0:2), 6, 14);
      } else if (e.type === 'drake') {
        // Fire drake
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.moveTo(ex+e.w/2, ey+2);
        ctx.lineTo(ex+e.w-4, ey+e.h/2);
        ctx.lineTo(ex+e.w/2, ey+e.h-4);
        ctx.lineTo(ex+4, ey+e.h/2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(ex+e.w/2, ey+e.h/2, 8, 0, Math.PI*2);
        ctx.fill();
        // Eye
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(ex+e.w/2+e.facing*4, ey+e.h/2-2, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(ex+e.w/2+e.facing*5, ey+e.h/2-2, 1.5, 0, Math.PI*2);
        ctx.fill();
        // Wing flap
        ctx.fillStyle = '#cc4400';
        const wingA = Math.sin(this.frame*0.12+e.floatPhase)*15;
        ctx.beginPath();
        ctx.moveTo(ex+e.w/2-6, ey+8);
        ctx.lineTo(ex-6, ey+2+wingA);
        ctx.lineTo(ex+4, ey+14);
        ctx.closePath();
        ctx.fill();
      } else if (e.type === 'shade') {
        // Shadow creature
        ctx.fillStyle = `rgba(40,20,60,0.8)`;
        ctx.shadowColor = '#aa00ff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.ellipse(ex+e.w/2, ey+e.h/2, 14, 12+Math.sin(this.frame*0.06)*3, 0, 0, Math.PI*2);
        ctx.fill();
        // Glowing eyes
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.arc(ex+e.w/2-5, ey+e.h/2-2, 2, 0, Math.PI*2);
        ctx.arc(ex+e.w/2+5, ey+e.h/2-2, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (e.type === 'boss') {
        // Grand boss
        ctx.fillStyle = '#6600aa';
        ctx.shadowColor = '#aa00ff';
        ctx.shadowBlur = 15;
        ctx.fillRect(ex+6, ey+6, e.w-12, e.h-12);
        // Crown
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(ex+12, ey-4, e.w-24, 6);
        ctx.fillRect(ex+16, ey-10, 5, 8);
        ctx.fillRect(ex+e.w/2-2, ey-14, 5, 12);
        ctx.fillRect(ex+e.w-22, ey-10, 5, 8);
        // Face
        ctx.fillStyle = '#ff2244';
        ctx.fillRect(ex+14, ey+14, 8, 8);
        ctx.fillRect(ex+e.w-22, ey+14, 8, 8);
        // Mouth
        ctx.fillStyle = '#fff';
        ctx.fillRect(ex+16, ey+30, e.w-32, 4);
        ctx.shadowBlur = 0;
        // Boss label
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 9px Orbitron, monospace';
        ctx.textAlign = 'center';
        ctx.fillText('BOSS', ex+e.w/2, ey-18);
        ctx.textAlign = 'left';
      }
      
      // HP bar
      if (!e.dead && e.hp < e.maxHp) {
        const bw = e.type === 'boss' ? 60 : 36;
        ctx.fillStyle = '#000';
        ctx.fillRect(ex, ey-6, bw, 3);
        ctx.fillStyle = e.hp/e.maxHp > 0.5 ? '#39ff14' : e.hp/e.maxHp > 0.25 ? '#ffd700' : '#ff2244';
        ctx.fillRect(ex, ey-6, bw*(e.hp/e.maxHp), 3);
      }
      
      ctx.globalAlpha = 1;
    });
    
    // ---- PLAYER ----
    const P = this.player;
    
    // Trail
    P.trail.forEach(t => {
      ctx.globalAlpha = t.alpha * 0.35;
      ctx.fillStyle = '#6633ff';
      ctx.fillRect(t.x+4, t.y+4, P.w-8, P.h-8);
    });
    ctx.globalAlpha = 1;
    
    // Player character - magical rune weaver
    ctx.save();
    if (P.invincible > 0 && Math.floor(this.frame/3)%2) ctx.globalAlpha = 0.4;
    
    const px = P.x, py = P.y;
    const facingFlip = P.facing < 0;
    
    ctx.save();
    if (facingFlip) { ctx.translate(px+P.w, py); ctx.scale(-1,1); }
    else { ctx.translate(px, py); }
    
    // Body glow
    ctx.shadowColor = '#aa66ff';
    ctx.shadowBlur = 6;
    
    // Robe body
    const robeGrad = ctx.createLinearGradient(8, 8, 8, P.h-4);
    robeGrad.addColorStop(0, '#2a1a55');
    robeGrad.addColorStop(1, '#1a0d33');
    ctx.fillStyle = robeGrad;
    ctx.beginPath();
    ctx.moveTo(P.w/2, 18);
    ctx.lineTo(P.w-8, P.h-8);
    ctx.lineTo(P.w-4, P.h);
    ctx.lineTo(4, P.h);
    ctx.lineTo(8, P.h-8);
    ctx.closePath();
    ctx.fill();
    
    // Head
    ctx.fillStyle = '#ffd5b8';
    ctx.beginPath();
    ctx.arc(P.w/2, 16, 10, 0, Math.PI*2);
    ctx.fill();
    
    // Hood
    ctx.fillStyle = '#2a1a55';
    ctx.beginPath();
    ctx.arc(P.w/2, 14, 12, Math.PI, 0);
    ctx.fill();
    ctx.fillRect(P.w/2-12, 10, 24, 8);
    
    // Eyes (glow)
    ctx.fillStyle = '#aa66ff';
    ctx.shadowColor = '#aa66ff';
    ctx.shadowBlur = 4;
    ctx.beginPath();
    ctx.arc(P.w/2-4, 16, 1.5, 0, Math.PI*2);
    ctx.arc(P.w/2+4, 16, 1.5, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Belt rune
    ctx.fillStyle = '#aa66ff';
    ctx.fillRect(P.w/2-8, 32, 16, 2);
    
    // Staff (if not attacking)
    if (!P.attacking) {
      ctx.strokeStyle = '#664422';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(P.w-6, 20);
      ctx.lineTo(P.w-2, P.h-4);
      ctx.stroke();
      // Staff orb
      ctx.fillStyle = '#aa66ff';
      ctx.shadowColor = '#aa66ff';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(P.w-6, 18, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    } else {
      // Attack: staff swipe with magic arc
      const at = 1 - P.attackTimer/14;
      ctx.strokeStyle = '#664422';
      ctx.lineWidth = 2;
      const staffAngle = -1.5 + at * 3;
      const sx = P.w/2 + Math.cos(staffAngle)*25;
      const sty = 25 + Math.sin(staffAngle)*20;
      ctx.beginPath();
      ctx.moveTo(P.w/2, 25);
      ctx.lineTo(sx, sty);
      ctx.stroke();
      // Magic slash arc
      ctx.strokeStyle = `rgba(170,102,255,${1-at})`;
      ctx.shadowColor = '#aa66ff';
      ctx.shadowBlur = 10;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(P.w/2+10, 25, 30, staffAngle-0.5, staffAngle+0.5);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // Cape flutter
    ctx.fillStyle = 'rgba(100,50,200,0.6)';
    const capeFlutter = Math.sin(this.frame*0.1)*3;
    ctx.beginPath();
    ctx.moveTo(6, 22);
    ctx.lineTo(-2+capeFlutter, P.h-10);
    ctx.lineTo(10, P.h-6);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
    ctx.restore();
    
    // Particles
    this.particles.draw(ctx);
    
    ctx.restore(); // camera
    
    // Screen flash
    if (this.screenFlash > 0) {
      ctx.fillStyle = `rgba(170,102,255,${this.screenFlash*0.03})`;
      ctx.fillRect(0, 0, 1200, 900);
    }
    
    // Combo display
    if (this.combo > 1) {
      ctx.fillStyle = '#ffd700';
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 10;
      ctx.font = `bold ${28+this.combo*2}px Orbitron, sans-serif`;
      ctx.textAlign = 'right';
      ctx.fillText(`x${this.combo}`, 1180, 450);
      ctx.font = '10px Orbitron, monospace';
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fillText('COMBO', 1180, 465);
      ctx.textAlign = 'left';
      ctx.shadowBlur = 0;
    }
    
    ctx.restore();
  }
  
  // ===== GAME OVER =====
  gameOver() {
    this.state = 'dead';
    SFX.stopMusic();
    document.getElementById('deathSub').textContent = `Sua essencia se dispersou no reino ${this.world.level} com ${this.player.runes} runas coletadas`;
    document.getElementById('deathScreen').classList.add('show');
  }
  
  retry() {
    document.getElementById('deathScreen').classList.remove('show');
    this.player.hp = this.player.maxHp;
    this.player.ink = this.player.maxInk;
    this.player.x = 120;
    this.player.y = 400;
    this.player.vy = 0;
    this.player.vx = 0;
    this.player.invincible = 50;
    this.state = 'playing';
    this.updateHUD();
    SFX.startMusic();
  }
  
  // ===== LOOP =====
  loop(ts) {
    this.update();
    this.draw();
    requestAnimationFrame(t => this.loop(t));
  }
}

// ===== INIT =====
const game = new Game();
</script>
</body>
</html>
